diff a/extern/btyacc/types_fix.c b/extern/btyacc/types_fix.c	(rejected hunks)
@@ -45,11 +70,57 @@ void write_conflicts(char* symbol, int ruleno)
 	{
 		ffile = fopen("conflicts_list.txt", "a");
 	}
-	if (ffile == NULL) {
+
+	if (ffile == NULL)
+	{
 		error(lineno, 0, 0, "Cannot open conflicts_list file for writing %s", "conflicts_list.txt");
+		return;
 	}
-	else {
-		fprintf(ffile, "%d:%s conflict on line %d\n", ++conflict_count, symbol, rule_line[ruleno]);
-		fclose(ffile);
+
+	for (int i = sp->nshifts - 1; i >= 0; i--)
+	{
+		int state = sp->shift[i];
+		int symbol = accessing_symbol[state];
+		if (i > 0)
+			fprintf(ffile, "%s -> ", symbol_name[symbol]);
+		else
+			fprintf(ffile, "%s\n", symbol_name[symbol]);
 	}
-}
\ No newline at end of file
+	fclose(ffile);
+
+}
+
+void MOD_write_conflicts(const action* firstRule, action* secondRule)
+{
+	FILE* ffile = NULL;
+	if (!first_open_conflict_file)
+	{
+		ffile = fopen("conflicts_list.txt", "w");
+		first_open_conflict_file = 1;
+	}
+	else
+	{
+		ffile = fopen("conflicts_list.txt", "a");
+	}
+	if (ffile == NULL)
+	{
+		error(lineno, 0, 0, "Cannot open conflicts_list file for writing %s", "conflicts_list.txt");
+		return;
+	}
+
+	const char* symbol = symbol_name[firstRule->symbol];
+	const char* type = firstRule->action_code == SHIFT ? "shift/reduce" : "reduce/reduce";
+
+	//const char* bp = symbol_name[firstRuleno];
+	fprintf(ffile, "%s: %s conflict on lines %s:%d VS %s:%d\n", symbol, type,
+		MOD_file_name, rule_line[firstRule->number],
+		MOD_file_name, rule_line[secondRule->number]);
+
+	if (firstRule->action_code == SHIFT)
+	{
+		MOD_write_shifts(firstRule);
+		MOD_write_shifts(secondRule);
+	}
+	fclose(ffile);
+
+}
